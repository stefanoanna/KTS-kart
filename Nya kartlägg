    /*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package autonavigate;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.io.*;


    

       


/**
 *
 * @author christianchamaly
 */
public class Kartläggningrutt {
    private List<Vertex> nodes;
    private List<Edge> edges;
    private DataStore ds;
   private BluetoothClient bt;
   private ControlUIny gui;
        
   
    
    public Kartläggningrutt(DataStore ds) {
        this.ds = ds;
        
    
 
    }
    
    public void createPlan2(){
       
    



         nodes = new ArrayList<Vertex>();
         edges = new ArrayList<Edge>();
         
         
// Set up grid network for path finding
for (int i = 0; i < ds.columns; i++) { 
   for (int j = 0; j < ds.rows; j++) {
     
        Vertex location = new Vertex("" + (i*ds.rows + j), "Nod #" + (i*ds.rows + j)); ;
        nodes.add(location);
    }
}
System.out.println("columns: "+ds.columns);
System.out.println("rows: "+ds.rows);

double cost = 1;


for (int i = 0; i < ds.rows; i++) {
  for (int j = 0; j < ds.columns - 1 ; j++) { // Add horizontal links in both directions
      cost = 1;
        if (ds.ObstacleMatrix[i][j] != 0 || ds.ObstacleMatrix[i][j + 1] != 0) {
            continue;
        }    

      Edge dirA = new Edge("r" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get(i*ds.columns + j + 1), cost);
      edges.add(dirA);
      Edge dirB = new Edge("l" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
      edges.add(dirB);
      if(i < ds.rows - 1 ){
          cost = 1.4;
          if(ds.ObstacleMatrix[i + 1][j + 1] != 0){
              continue;
          }
          Edge dirC = new Edge("1d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i+1)*ds.columns + j + 1), cost);
          edges.add(dirC);
          Edge dirD = new Edge("2d" + nodes.get(i*ds.columns + j), nodes.get((i+1)*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
          edges.add(dirD); }
      if(i > 0){ 
          cost = 1.4;
          if(ds.ObstacleMatrix[i - 1][j + 1] != 0){
              continue;
          }
      Edge dirE = new Edge("3d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i-1)*ds.columns + j + 1), cost);
      edges.add(dirE);
      Edge dirF = new Edge("4d" + nodes.get(i*ds.columns + j), nodes.get((i-1)*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
      edges.add(dirF); 
      }
  } 
}
for (int i = 0; i < ds.rows - 1; i++) {
for (int j = 0; j < ds.columns; j++) { // Add vertical links in both directions 
    cost = 1;
    
    if(ds.ObstacleMatrix[i + 1][j] != 0){
       continue;
    }
    Edge dirC = new Edge("d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i+1)*ds.columns + j ), cost);
    edges.add(dirC);
    Edge dirD = new Edge("u" + nodes.get(i*ds.columns + j), nodes.get((i+1)*ds.columns + j), nodes.get(i*ds.columns + j ), cost);
    edges.add(dirD);
} 
}

Graph graph = new Graph(nodes, edges);
DijkstrasAlgorithm dijkstra = new DijkstrasAlgorithm(graph);
int startnode = 0;      
int endnode = 0;
// ❌ Rensa tidigare ritad väg från ObstacleMatrix



// Convert from Location coordinates to node id
for (int j = 0; j < ds.locations-1; j++) {
    
    
             switch (ds.Riktning[j+1]) {
                
                 case 'N':
                     {
                         
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + (x+1);
                         x = (int)(ds.LocationX[j+1]/ds.gridsize);
                         y = (int)(ds.LocationY[j+1]/ds.gridsize);
                         endnode = (int)((y+1) * ds.columns) + x;   
                         break;
                         
                         
                         
                         
                         
                     }
                 case 'E':
                     {
                       
                        int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + x+1;
                         x = (int)(ds.LocationX[j+1]/ds.gridsize);
                         y = (int)(ds.LocationY[j+1]/ds.gridsize);
                         endnode = (int)((y) * ds.columns) + x+1; 
                         break;
                         
                              
                     }
                 case 'W':
                    {
                        
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                         startnode = (int)((y)* ds.columns) + x+1;
                         x = (int)(ds.LocationX[j+1]/ds.gridsize);
                         y = (int)(ds.LocationY[j+1]/ds.gridsize);
                         endnode = (int)((y) * ds.columns) + x-1;     
                         break;
                         
                                                                   
                     }
                 case 'S':
                     {
                        
                        int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + x+1;
                         x = (int)(ds.LocationX[j+1]/ds.gridsize);
                         y = (int)(ds.LocationY[j+1]/ds.gridsize);
                         endnode = (int)((y-1) * ds.columns) + x;    
                         break;
                         
                         
                         
                         
                         
                         
                     }
                 default:
                         
                         break;
                         
             }
 System.out.println(ds.Riktning);


//ds.antalrut = path.size();
//ds.xrobpos = new double[path.size()];
//ds.yrobpos = new double[path.size()];

    dijkstra.execute(nodes.get(startnode));
LinkedList<Vertex> path = dijkstra.getPath(nodes.get(endnode));

if (path == null || path.isEmpty()) {
    System.out.println("❌ Ingen väg hittades från " + startnode + " till " + endnode);
    return;  // Avbryt ruttplaneringen
}

//try (PrintWriter cmdWriter = new PrintWriter(new FileWriter("command.txt"))) {
// Hämta kortaste vägen
for (int i = 0; i < path.size() - 1; i++) {
    int ipos1 = Integer.parseInt(path.get(i).getId()) / ds.columns;
    int jpos1 = Integer.parseInt(path.get(i).getId()) % ds.columns;

    

    // Markera rutten (kan vara kvar)
    ds.ObstacleMatrix[ipos1][jpos1] = 3;

  

    

    
}
for (int i = 0; i < path.size() - 1;) {
    int ipos1 = Integer.parseInt(path.get(i).getId()) / ds.columns;
    int jpos1 = Integer.parseInt(path.get(i).getId()) % ds.columns;

    int ipos2 = Integer.parseInt(path.get(i + 1).getId()) / ds.columns;
    int jpos2 = Integer.parseInt(path.get(i + 1).getId()) % ds.columns;

    // Bestäm riktning (inklusive diagonala riktningar)
    String direction = "";
    if (ipos2 == ipos1 && jpos2 == jpos1 + 1) direction = "0";        // Öst
    else if (ipos2 == ipos1 && jpos2 == jpos1 - 1) direction = "180";  // Väst
    else if (jpos2 == jpos1 && ipos2 == ipos1 + 1) direction = "90";   // Syd
    else if (jpos2 == jpos1 && ipos2 == ipos1 - 1) direction = "270";  // Nord
    else if (ipos2 == ipos1 + 1 && jpos2 == jpos1 + 1) direction = "45";   // Sydöst
    else if (ipos2 == ipos1 + 1 && jpos2 == jpos1 - 1) direction = "135";  // Sydväst
    else if (ipos2 == ipos1 - 1 && jpos2 == jpos1 - 1) direction = "225";  // Nordväst
    else if (ipos2 == ipos1 - 1 && jpos2 == jpos1 + 1) direction = "315";  // Nordöst

    // Räkna sträckan i samma riktning
    int length = 1;
    int finalRow = ipos2;
    int finalCol = jpos2;

    while (i + length < path.size() - 1) {
        int nextIpos = Integer.parseInt(path.get(i + length).getId()) / ds.columns;
        int nextJpos = Integer.parseInt(path.get(i + length).getId()) % ds.columns;

        // Kontrollera om riktningen ändras
        if ((direction.equals("0") && nextIpos == ipos1 && nextJpos == jpos1 + length) ||     // Öst
            (direction.equals("180") && nextIpos == ipos1 && nextJpos == jpos1 - length) ||    // Väst
            (direction.equals("90") && nextJpos == jpos1 && nextIpos == ipos1 + length) ||     // Syd
            (direction.equals("270") && nextJpos == jpos1 && nextIpos == ipos1 - length) ||    // Nord
            (direction.equals("45") && nextIpos == ipos1 + length && nextJpos == jpos1 + length) ||   // Sydöst
            (direction.equals("135") && nextIpos == ipos1 + length && nextJpos == jpos1 - length) ||  // Sydväst
            (direction.equals("225") && nextIpos == ipos1 - length && nextJpos == jpos1 - length) ||  // Nordväst
            (direction.equals("315") && nextIpos == ipos1 - length && nextJpos == jpos1 + length)) {  // Nordöst
            finalRow = nextIpos;
            finalCol = nextJpos;
            length++; // Fortsätt i samma riktning
        } else {
            break; // Riktningen ändras
        }
    }

    // Skapa kommandosträngen med slutpositionen (rad, kol) och riktning
    String command = "GT," + finalCol * ds.gridsize + "," + finalRow * ds.gridsize + "," + direction;
    System.out.println("➡️ Skickar riktning: " + command);

    // Skicka kommandot till AGV via BluetoothfinalRow
    bt.sendDirection(command);

    // ⏳ Vänta på bekräftelse från AGV
    int timeoutMs = 5000;  // max 5 sekunder
    int waited = 0;
    boolean acked = false;

    while (waited < timeoutMs) {
        try {
            if (bt.waitForAck()) {
                System.out.println("✅ Bekräftelse mottagen!");
                acked = true;
                break;
            }
            Thread.sleep(50); // Undvik busy wait
            waited += 50;
        } catch (InterruptedException e) {
            System.out.println("⚠️ Väntan avbruten: " + e.getMessage());
            break;
        }
    }

    // Kontrollera om timeout inträffade
    if (!acked) {
        System.out.println("❌ Inget svar från AGV efter " + timeoutMs / 1000 + " sekunder.");
        break;
    }

    // Flytta index framåt med längden
    i += length;
}



}



    }
    

    }

