package autonavigate;

import javax.microedition.io.Connector;
import javax.microedition.io.StreamConnection;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class BluetoothClient {

    private static final String AGV_URL = "btspp://b827eb7bd6ad:1;authenticate=false;encrypt=false;master=false"; // 

    private StreamConnection connection;
    private PrintWriter writer;
    private BufferedReader reader;
    private ControlUIny gui;
    private DataStore ds;
    private final List<int[]> lastLidarPoints = new ArrayList<>();
    private AutoNavigate an;
    private MapPanel mp;
    private double headingOffset = 0.0;

    public BluetoothClient(ControlUIny gui, DataStore ds, AutoNavigate an) {
        this.gui = gui;
        this.ds = ds;
        this.an = an;
       
        
    }

    public void connect() {
        try {
            gui.appendStatus("üîå Ansluter till AGV...\n");

            connection = (StreamConnection) Connector.open(AGV_URL);
            OutputStream out = connection.openOutputStream();
            InputStream in = connection.openInputStream();

            writer = new PrintWriter(out, true);
            reader = new BufferedReader(new InputStreamReader(in));

            gui.appendStatus("‚úÖ Ansluten! Anslutningen √§r √∂ppen.\n");
             
      //  gui.appendStatus("üì° Skickade 'position' till AGV f√∂r att starta DWM-positionering...\n");

        // üü¢ Starta lyssning f√∂r DWM-positioner
        


        } catch (Exception e) {
            gui.appendStatus("‚ùå Anslutningsfel: " + e.getMessage() + "\n");
            e.printStackTrace();
        }
    }
    public void sendPositionCommand() {
    if (!isConnected()) return;
    writer.println("position");
    writer.flush();
    gui.appendStatus("? Skickade 'position' till AGV.\n");
}

// Skickar "lidar" manuellt
public void sendLidarCommand() {
    if (!isConnected()) return;
    writer.println("lidar");
    writer.flush();
    gui.appendStatus("? Skickade 'lidar' till AGV.\n");
}

public void sendLjusCommand() {
    if (!isConnected()) return;
    writer.println("ljus");
    writer.flush();
    gui.appendStatus("? Skickade 'ljus' till AGV.\n");
}

    public void ping() {
    if (connection == null || writer == null) {
        gui.appendStatus("‚ùå Ingen anslutning. Kan inte pinga.\n");
        return;
    }
    try {
        writer.println("ping");
        writer.println("STOP");// Skicka "ping"
        writer.flush();          // S√§kerst√§ll att det verkligen g√•r ut!

        gui.appendStatus("‚úÖ Anslutning OK. Ping skickad.\n");
    } catch (Exception e) {
        gui.appendStatus("‚ùå Anslutning f√∂rlorad: " + e.getMessage() + "\n");
    }
}

public void receiveLidarData() {
    if (!isConnected()) {
        gui.appendStatus("‚ùå Inte ansluten till AGV.\n");
        return;
    }

    an.startRuttplanering(); // Initial planering

    try {
        writer.println("lidar");
        gui.repaint();
        gui.appendStatus("üì° Startar mottagning av LIDAR-data...\n");

        while (true) {
            String line = reader.readLine();
            if (line == null) break;

            if (line.startsWith("LIDAR:")) {
                boolean blockerat = false;

                // Rensa gamla hinder
                
                String[] parts = line.substring(6).split(",");
                if (parts.length != 360) {
                    gui.appendStatus("‚ö†Ô∏è Felaktig LIDAR-vektor (inte 360 v√§rden).\n");
                    continue;
                }

                for (int i = 0; i < parts.length; i++) {
                    try {
                        double angleRad = Math.toRadians(i);
                        double distance = Double.parseDouble(parts[i].trim());

                        if (distance <= 10.0 || distance == 0.0) continue;

                        double obsX = ds.robotX + distance * Math.cos(angleRad);
                        double obsY = ds.robotY + distance * Math.sin(angleRad);

                        int row = (int) Math.round(obsY / ds.gridsize);
                        int col = (int) Math.round(obsX / ds.gridsize);

                        if (row >= 0 && row < ds.rows && col >= 0 && col < ds.columns) {
                            // üí° Kontrollera om detta nya hinder blockerar rutten (ObstacleMatrix == 3)
                            if (ds.ObstacleMatrix[row][col] == 3) {
                                blockerat = true;
                            }
                            ds.ObstacleMatrix[row][col] = 1;
                            lastLidarPoints.add(new int[]{row, col});
                        }

                    } catch (NumberFormatException e) {
                        gui.appendStatus("‚ö†Ô∏è Ogiltigt LIDAR-v√§rde vid index " + i + "\n");
                    }
                }

                ds.buildObstaclesFromMapping();
                gui.repaint();

                if (blockerat) {
                    gui.appendStatus("üõë Rutt blockerad ‚Äì skickar STOP...\n");
                 //   writer.println("stop");
                    writer.flush();
                     for (int i = 0; i < ds.rows; i++) {
                         for (int j = 0; j < ds.columns; j++) {
                             if (ds.ObstacleMatrix[i][j] == 3 )
                             {
                                 ds.ObstacleMatrix[i][j] = 0;
                             }
                         }
                     }
                    gui.appendStatus("üîÑ R√§knar om rutt...\n");
                    an.startKartplanering();
                    gui.repaint();

                 //   try {
                   //     Thread.sleep(2000);
                  //  } catch (InterruptedException e) {
                  //      gui.appendStatus("‚ö†Ô∏è Avbrott i v√§ntan: " + e.getMessage() + "\n");
                    //}

                    gui.appendStatus("üì° √Öterupptar LIDAR-stream...\n");
                   // writer.println("lidar");
                 //   writer.flush();
                }
            }
        }

    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid LIDAR-mottagning: " + e.getMessage() + "\n");
    }
  //  writer.println("stop");
}














    public void transfer() {
        try {
            if (!isConnected()) return;

            File commandFile = new File("command.txt");
            if (!commandFile.exists() || commandFile.length() == 0) {
                gui.appendStatus("‚ö†Ô∏è Inget att √∂verf√∂ra i command.txt.\n");
                return;
            }

            List<String> cmds = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(commandFile))) {
                String line;
                while ((line = br.readLine()) != null) {
                    cmds.add(line);
                }
            }

            for (String cmd : cmds) {
                gui.appendStatus("‚û°Ô∏è Skickar: " + cmd + "\n");
                writer.println(cmd);
                writer.flush();
            }

            File statusFile = new File("status.txt");
            try (PrintWriter statusWriter = new PrintWriter(new FileWriter(statusFile))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    gui.appendStatus("‚úÖ Mottaget: " + line + "\n");
                    statusWriter.println(line);
                    if (line.contains("klar")) break; // T.ex. signalera slut
                }
            }

        } catch (IOException e) {
            gui.appendStatus("‚ùå √ñverf√∂ring misslyckades: " + e.getMessage() + "\n");
        }
    }
    
    public void requestStatus() { //l√§gg in motsvarande i raspberryn
    if (!isConnected()) return;

    try {
        writer.println("status?");
        String response = reader.readLine();
        if (response != null) {
            gui.appendStatus("üîÑ Status fr√•n AGV: " + response + "\n");
        }
    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid statusf√∂rfr√•gan: " + e.getMessage() + "\n");
    }
}
 public void startPositionTracking() {
    gui.appendStatus("üöÄ Startar tr√•d f√∂r positionsuppdatering...\n");

    new Thread(() -> {
        try {
            while (true) {
                String line = reader.readLine();
                if (line == null) break;

                if (line.startsWith("POS:")) {
                    String[] parts = line.substring(4).split(",");
                    if (parts.length >= 2) {
                        try {
                            double x = Double.parseDouble(parts[0].trim());
                            double y = Double.parseDouble(parts[1].trim());

                            ds.robotX = x * 100;
                            ds.robotY = y * 100;
                            gui.appendStatus(String.format("üìç Uppdaterad position: X=%.1f cm, Y=%.1f cm\n", ds.robotX, ds.robotY));
                            gui.repaint();
                        } catch (NumberFormatException e) {
                            gui.appendStatus("‚ö†Ô∏è Kunde inte tolka position: " + e.getMessage() + "\n");
                        }
                    }
                }
            }
        } catch (IOException e) {
            gui.appendStatus("‚ùå Fel vid l√§sning av position: " + e.getMessage() + "\n");
        }
    }).start();
}


public void startUnifiedReceiver() {
    if (!isConnected()) return;

    gui.appendStatus("üöÄ Startar kombinerad mottagning av position och LIDAR...\n");

    new Thread(() -> {
        boolean initialRouteCalculated = false;  // Flagga f√∂r initial rutt

        try {
            while (true) {
                if (reader == null) {
                    gui.appendStatus("‚ùó BufferedReader √§r null ‚Äì anslutning inte klar?\n");
                }

                String line = reader.readLine();
                if (line == null) {
                    gui.appendStatus("‚ùó Str√∂mmen verkar st√§ngd.\n");
                    break;
                }

                gui.appendStatus("üì® Mottaget: " + line + "\n");

                // Hantering av positionsdata
                if (line.startsWith("POS:")) {
                    String[] parts = line.substring(4).split(",");
                    if (parts.length >= 2) {
                        try {
                            double x = Double.parseDouble(parts[0].trim());
                            double y = Double.parseDouble(parts[1].trim());

                            ds.robotX = x;
                            ds.robotY = y;

                            gui.appendStatus(String.format("üìç Uppdaterad position: X=%.1f cm, Y=%.1f cm\n", ds.robotX, ds.robotY));
                            gui.repaint();

                            // H√§r startar du ruttber√§kning f√∂rsta g√•ngen position finns
                            if (!initialRouteCalculated) {
                                initialRouteCalculated = true;
                                gui.appendStatus("üó∫Ô∏è Startar initial ruttber√§kning...\n");
                                new Thread(() -> {
                                    an.startKartplanering();
                                    gui.repaint();
                                    gui.appendStatus("‚úÖ Initial rutt ber√§knad.\n");
                                }).start();
                            }
                        } catch (NumberFormatException e) {
                            gui.appendStatus("‚ö†Ô∏è Felaktig POS-data: " + line + "\n");
                        }
                    }
                }

                // Hantering av LIDAR-data
                else if (line.startsWith("LIDAR:")) {
                    String[] parts = line.substring(6).split(",");
                    if (parts.length != 360) {
                        gui.appendStatus("‚ö†Ô∏è Felaktig LIDAR-vektor (ej 360 v√§rden): " + parts.length + "\n");
                        continue;
                    }

                    boolean blockerat = false;
                    for (int i = 0; i < parts.length; i++) {
                        try {
                            double angleRad = Math.toRadians(i);
                            double distance = Double.parseDouble(parts[i].trim());

                            if (distance <= 30.0 || distance >= 500.0 || distance == 0) continue;

                            double deltaX = distance * Math.cos(angleRad);
                            double deltaY = distance * Math.sin(angleRad);

                            double obsX = ds.robotX + deltaX;
                            double obsY = ds.robotY - deltaY;

                            int row = (int) (obsY / ds.gridsize);
                            int col = (int) (obsX / ds.gridsize);

                            if (row >= 0 && row < ds.rows && col >= 0 && col < ds.columns) {
                                if (ds.ObstacleMatrix[row][col] == 3) blockerat = true;
                                ds.ObstacleMatrix[row][col] = 1;
                                lastLidarPoints.add(new int[]{row, col});
                            }

                        } catch (NumberFormatException e) {
                            gui.appendStatus("‚ö†Ô∏è Ogiltigt LIDAR-v√§rde vid index " + i + ": " + parts[i] + "\n");
                        }
                    }

                    gui.repaint();

                    if (blockerat) {
                        gui.appendStatus("üõë Rutt blockerad ‚Äì r√§knar om...\n");
                        new Thread(() -> {
                            for (int i = 0; i < ds.rows; i++) {
                                for (int j = 0; j < ds.columns; j++) {
                                    if (ds.ObstacleMatrix[i][j] == 3) ds.ObstacleMatrix[i][j] = 0;
                                }
                            }
                            an.startKartplanering();
                            gui.appendStatus("‚úÖ Ny rutt ber√§knad efter blockering.\n");
                        }).start();
                    }
                } else {
                    gui.appendStatus("‚ÑπÔ∏è Ok√§nt meddelande: " + line + "\n");
                }
            }
        } catch (IOException e) {
            gui.appendStatus("‚ùå Fel vid l√§sning: " + e.getMessage() + "\n");
        }
    }, "BT-Receiver").start();
}


 public void sendDirection(String dir) {
    if (!isConnected()) return;
    writer.println(dir);
    writer.flush();
    
}
public boolean waitForAck() {
    int timeoutMs = 10000;  // Max v√§ntetid i millisekunder (10 sek)
    int waited = 0;         // Hur l√§nge vi har v√§ntat
    int delayMs = 100;      // Intervallet mellan varje l√§sning

    try {
        while (waited < timeoutMs) {
            if (reader.ready()) {
                String ack = reader.readLine();
                if ("klar".equalsIgnoreCase(ack.trim())) {
                    gui.appendStatus("‚úÖ AGV bekr√§ftade steg: klar\n");
                    return true;
                } else {
                    gui.appendStatus("‚ÑπÔ∏è Mottaget annat √§n klar: " + ack + "\n");
                }
            }
            // V√§nta kort innan n√§sta l√§sning
            Thread.sleep(delayMs);
            waited += delayMs;
        }
        // Om vi har v√§ntat f√∂r l√§nge utan att f√• ACK
        gui.appendStatus("‚ùó Timeout: Ingen bekr√§ftelse fr√•n AGV efter " + (timeoutMs / 1000) + " sekunder.\n");
        stopRobot();  // Anropa en metod f√∂r att stoppa roboten vid timeout
    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid v√§ntan p√• klar: " + e.getMessage() + "\n");
    } catch (InterruptedException e) {
        gui.appendStatus("‚ö†Ô∏è V√§ntan avbruten: " + e.getMessage() + "\n");
    }

    return false;
}

private void stopRobot() {
    try {
        writer.println("STOP");
        writer.flush();
        gui.appendStatus("üö® N√∂dstopp skickat till AGV!\n");
    } catch (Exception e) {
        gui.appendStatus("‚ùå Fel vid s√§ndning av n√∂dstopp: " + e.getMessage() + "\n");
    }
}

// === N√ñDSTOPP ===
public void emergencyStop() {
    if (!isConnected()) {
        gui.appendStatus("‚ùå Ingen anslutning. Kan inte skicka n√∂dstopp.\n");
        return;
    }
    try {
        // Skicka n√∂dstoppkommandot "STOP" till AGV
        writer.println("STOP");
        writer.flush();
        gui.appendStatus("üö® N√∂dstopp skickat till AGV!\n");
    } catch (Exception e) {
        gui.appendStatus("‚ùå Fel vid s√§ndning av n√∂dstopp: " + e.getMessage() + "\n");
    }
}




    private boolean isConnected() {
        if (connection == null || writer == null || reader == null) {
            gui.appendStatus("‚ö†Ô∏è Inte ansluten till AGV. Tryck p√• Anslut f√∂rst.\n");
            return false;
        }
        return true;
    }

    public void disconnect() {
        try {
            if (connection != null) connection.close();
            gui.appendStatus("üîå Anslutningen st√§ngd.\n");
        } catch (IOException e) {
            gui.appendStatus("‚ö†Ô∏è Fel vid fr√•nkoppling: " + e.getMessage() + "\n");
        }
    }
}
