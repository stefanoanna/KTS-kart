package autonavigate;

import javax.microedition.io.Connector;
import javax.microedition.io.StreamConnection;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class BluetoothClient {

    private static final String AGV_URL = "btspp://b827eb7bd6ad:1;authenticate=false;encrypt=false;master=false"; // 

    private StreamConnection connection;
    private PrintWriter writer;
    private BufferedReader reader;
    private ControlUIny gui;
    private DataStore ds;
    private final List<int[]> lastLidarPoints = new ArrayList<>();
    private AutoNavigate an;
    private MapPanel mp;
    

    public BluetoothClient(ControlUIny gui, DataStore ds, AutoNavigate an) {
        this.gui = gui;
        this.ds = ds;
        this.an = an;
       
        
    }

    public void connect() {
        try {
            gui.appendStatus("üîå Ansluter till AGV...\n");

            connection = (StreamConnection) Connector.open(AGV_URL);
            OutputStream out = connection.openOutputStream();
            InputStream in = connection.openInputStream();

            writer = new PrintWriter(out, true);
            reader = new BufferedReader(new InputStreamReader(in));

            gui.appendStatus("‚úÖ Ansluten! Anslutningen √§r √∂ppen.\n");
             
      //  gui.appendStatus("üì° Skickade 'position' till AGV f√∂r att starta DWM-positionering...\n");

        // üü¢ Starta lyssning f√∂r DWM-positioner
        


        } catch (Exception e) {
            gui.appendStatus("‚ùå Anslutningsfel: " + e.getMessage() + "\n");
            e.printStackTrace();
        }
    }
    public void sendPositionCommand() {
    if (!isConnected()) return;
    writer.println("position");
    writer.flush();
    gui.appendStatus("? Skickade 'position' till AGV.\n");
}

// Skickar "lidar" manuellt
public void sendLidarCommand() {
    if (!isConnected()) return;
    writer.println("lidar");
    writer.flush();
    gui.appendStatus("? Skickade 'lidar' till AGV.\n");
}

    public void ping() {
    if (connection == null || writer == null) {
        gui.appendStatus("‚ùå Ingen anslutning. Kan inte pinga.\n");
        return;
    }
    try {
        writer.println("ping");  // Skicka "ping"
        writer.flush();          // S√§kerst√§ll att det verkligen g√•r ut!

        gui.appendStatus("‚úÖ Anslutning OK. Ping skickad.\n");
    } catch (Exception e) {
        gui.appendStatus("‚ùå Anslutning f√∂rlorad: " + e.getMessage() + "\n");
    }
}

public void receiveLidarData() {
    if (!isConnected()) {
        gui.appendStatus("‚ùå Inte ansluten till AGV.\n");
        return;
    }

    an.startRuttplanering(); // Initial planering

    try {
        writer.println("lidar");
        gui.repaint();
        gui.appendStatus("üì° Startar mottagning av LIDAR-data...\n");

        while (true) {
            String line = reader.readLine();
            if (line == null) break;

            if (line.startsWith("LIDAR:")) {
                boolean blockerat = false;

                // Rensa gamla hinder
                
                String[] parts = line.substring(6).split(",");
                if (parts.length != 360) {
                    gui.appendStatus("‚ö†Ô∏è Felaktig LIDAR-vektor (inte 360 v√§rden).\n");
                    continue;
                }

                for (int i = 0; i < parts.length; i++) {
                    try {
                        double angleRad = Math.toRadians(i);
                        double distance = Double.parseDouble(parts[i].trim());

                        if (distance <= 100.0 || distance == 0.0) continue;

                        double obsX = ds.robotX + distance * Math.cos(angleRad);
                        double obsY = ds.robotY + distance * Math.sin(angleRad);

                        int row = (int) Math.round(obsY / ds.gridsize);
                        int col = (int) Math.round(obsX / ds.gridsize);

                        if (row >= 0 && row < ds.rows && col >= 0 && col < ds.columns) {
                            // üí° Kontrollera om detta nya hinder blockerar rutten (ObstacleMatrix == 3)
                            if (ds.ObstacleMatrix[row][col] == 3) {
                                blockerat = true;
                            }
                            ds.ObstacleMatrix[row][col] = 1;
                            lastLidarPoints.add(new int[]{row, col});
                        }

                    } catch (NumberFormatException e) {
                        gui.appendStatus("‚ö†Ô∏è Ogiltigt LIDAR-v√§rde vid index " + i + "\n");
                    }
                }

                ds.buildObstaclesFromMapping();
                gui.repaint();

                if (blockerat) {
                    gui.appendStatus("üõë Rutt blockerad ‚Äì skickar STOP...\n");
                 //   writer.println("stop");
                    writer.flush();
                     for (int i = 0; i < ds.rows; i++) {
                         for (int j = 0; j < ds.columns; j++) {
                             if (ds.ObstacleMatrix[i][j] == 3 )
                             {
                                 ds.ObstacleMatrix[i][j] = 0;
                             }
                         }
                     }
                    gui.appendStatus("üîÑ R√§knar om rutt...\n");
                    an.startKartplanering();
                    gui.repaint();

                 //   try {
                   //     Thread.sleep(2000);
                  //  } catch (InterruptedException e) {
                  //      gui.appendStatus("‚ö†Ô∏è Avbrott i v√§ntan: " + e.getMessage() + "\n");
                    //}

                    gui.appendStatus("üì° √Öterupptar LIDAR-stream...\n");
                   // writer.println("lidar");
                    writer.flush();
                }
            }
        }

    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid LIDAR-mottagning: " + e.getMessage() + "\n");
    }
  //  writer.println("stop");
}














    public void transfer() {
        try {
            if (!isConnected()) return;

            File commandFile = new File("command.txt");
            if (!commandFile.exists() || commandFile.length() == 0) {
                gui.appendStatus("‚ö†Ô∏è Inget att √∂verf√∂ra i command.txt.\n");
                return;
            }

            List<String> cmds = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(commandFile))) {
                String line;
                while ((line = br.readLine()) != null) {
                    cmds.add(line);
                }
            }

            for (String cmd : cmds) {
                gui.appendStatus("‚û°Ô∏è Skickar: " + cmd + "\n");
                writer.println(cmd);
                writer.flush();
            }

            File statusFile = new File("status.txt");
            try (PrintWriter statusWriter = new PrintWriter(new FileWriter(statusFile))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    gui.appendStatus("‚úÖ Mottaget: " + line + "\n");
                    statusWriter.println(line);
                    if (line.contains("klar")) break; // T.ex. signalera slut
                }
            }

        } catch (IOException e) {
            gui.appendStatus("‚ùå √ñverf√∂ring misslyckades: " + e.getMessage() + "\n");
        }
    }
    
    public void requestStatus() { //l√§gg in motsvarande i raspberryn
    if (!isConnected()) return;

    try {
        writer.println("status?");
        String response = reader.readLine();
        if (response != null) {
            gui.appendStatus("üîÑ Status fr√•n AGV: " + response + "\n");
        }
    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid statusf√∂rfr√•gan: " + e.getMessage() + "\n");
    }
}
 public void startPositionTracking() {
    gui.appendStatus("üöÄ Startar tr√•d f√∂r positionsuppdatering...\n");

    new Thread(() -> {
        try {
            while (true) {
                gui.appendStatus("‚åõ V√§ntar p√• data fr√•n AGV (position)...\n");
                String line = reader.readLine();

                if (line == null) {
                    gui.appendStatus("‚ùó reader.readLine() gav null ‚Äì str√∂mmen kan vara st√§ngd.\n");
                    break;
                }

                gui.appendStatus("üì® [Position] Mottaget: " + line + "\n");

                if (line.startsWith("POS:")) {
                    String[] parts = line.substring(4).split(",");
                    if (parts.length >= 2) {
                        try {
                            double x = Double.parseDouble(parts[0].trim());
                            double y = Double.parseDouble(parts[1].trim());

                            ds.robotX = x * 100;
                            ds.robotY = y * 100;

                            gui.appendStatus(String.format("üìç Uppdaterad DWM-position: X=%.1f cm, Y=%.1f cm\n", ds.robotX, ds.robotY));
                            gui.repaint();
                        } catch (NumberFormatException e) {
                            gui.appendStatus("‚ö†Ô∏è Kunde inte tolka position: '" + line + "' ‚Äì " + e.getMessage() + "\n");
                        }
                    } else {
                        gui.appendStatus("‚ö†Ô∏è Fel format p√• POS-rad: " + line + "\n");
                    }
                } else {
                    gui.appendStatus("‚ÑπÔ∏è Andra data √§n position mottaget: " + line + "\n");
                }
            }
        } catch (IOException e) {
            gui.appendStatus("‚ùå Fel vid l√§sning av position: " + e.getMessage() + "\n");
        }
    }, "BT-PositionReceiver").start();
}

 public void startUnifiedReceiver() {
        if (!isConnected()) return;

        gui.appendStatus("üöÄ Startar kombinerad mottagning av position och LIDAR...\n");
        

        new Thread(() -> {
            try {
                while (true) {
                    if (reader == null) {
    gui.appendStatus("‚ùó BufferedReader √§r null ‚Äì anslutning inte klar?\n");
}

                    String line = reader.readLine();
                    if (line == null) {
                        gui.appendStatus("‚ùó Str√∂mmen verkar st√§ngd.\n");
                        break;
                    }

                    gui.appendStatus("üì® Mottaget: " + line + "\n");

                    if (line.startsWith("POS:")) {
                        String[] parts = line.substring(4).split(",");
                        if (parts.length >= 2) {
                            try {
                                double x = Double.parseDouble(parts[0].trim());
                                double y = Double.parseDouble(parts[1].trim());

                                ds.robotX = x * 100;
                                ds.robotY = y * 100;

                                gui.appendStatus(String.format("üìç Uppdaterad position: X=%.1f cm, Y=%.1f cm\n", ds.robotX, ds.robotY));
                                gui.repaint();
                            } catch (NumberFormatException e) {
                                gui.appendStatus("‚ö†Ô∏è Felaktig POS-data: " + line + "\n");
                            }
                        }
                    } else if (line.startsWith("LIDAR:")) {
                        String[] parts = line.substring(6).split(",");
                        if (parts.length != 360) {
                            gui.appendStatus("‚ö†Ô∏è Felaktig LIDAR-vektor (ej 360 v√§rden): " + parts.length + "\n");
                            continue;
                        }

                        lastLidarPoints.clear();
                        boolean blockerat = false;

                        for (int i = 0; i < parts.length; i++) {
                            try {
                                double angleRad = Math.toRadians(i);
                                double distance = Double.parseDouble(parts[i].trim());

                                if (distance <= 1.0 || distance == 0.0) continue;

                         double deltaX = distance * Math.cos(angleRad);
            double deltaY = distance * Math.sin(angleRad);

            double obsX = ds.robotX + deltaX;
            double obsY = ds.robotY - deltaY; // ‚úÖ Korrekt invertering f√∂r y-led

            int row = (int) Math.round(obsY / ds.gridsize);
            int col = (int) Math.round(obsX / ds.gridsize);



                                if (row >= 0 && row < ds.rows && col >= 0 && col < ds.columns) {
                                    if (ds.ObstacleMatrix[row][col] == 3) blockerat = true;
                                    ds.ObstacleMatrix[row][col] = 1;
                                    lastLidarPoints.add(new int[]{row, col});
                                }

                            } catch (NumberFormatException e) {
                                gui.appendStatus("‚ö†Ô∏è Ogiltigt LIDAR-v√§rde vid index " + i + ": " + parts[i] + "\n");
                            }
                        }

                        ds.buildObstaclesFromMapping();
                        gui.repaint();

                        if (blockerat) {
                            gui.appendStatus("üõë Rutt blockerad ‚Äì r√§knar om...\n");
                            for (int i = 0; i < ds.rows; i++) {
                                for (int j = 0; j < ds.columns; j++) {
                                    if (ds.ObstacleMatrix[i][j] == 3) ds.ObstacleMatrix[i][j] = 0;
                                }
                            }
                            an.startKartplanering();
                        }
                    } else {
                        gui.appendStatus("‚ÑπÔ∏è Ok√§nt meddelande: " + line + "\n");
                    }
                }
            } catch (IOException e) {
                gui.appendStatus("‚ùå Fel vid l√§sning: " + e.getMessage() + "\n");
            }
        }, "BT-Receiver").start();
    }
 public void sendDirection(String dir) {
    if (!isConnected()) return;
    writer.println(dir);
    writer.flush();
    gui.appendStatus("‚û°Ô∏è Skickade riktning: " + dir + "\n");
}
public boolean waitForAck() {
    try {
        String ack = reader.readLine();
        if ("klar".equalsIgnoreCase(ack.trim())) {
            gui.appendStatus("‚úÖ AGV bekr√§ftade steg: klar\n");
            return true;
        }
    } catch (IOException e) {
        gui.appendStatus("‚ùå Fel vid v√§ntan p√• klar: " + e.getMessage() + "\n");
    }
    return false;
}



    private boolean isConnected() {
        if (connection == null || writer == null || reader == null) {
            gui.appendStatus("‚ö†Ô∏è Inte ansluten till AGV. Tryck p√• Anslut f√∂rst.\n");
            return false;
        }
        return true;
    }

    public void disconnect() {
        try {
            if (connection != null) connection.close();
            gui.appendStatus("üîå Anslutningen st√§ngd.\n");
        } catch (IOException e) {
            gui.appendStatus("‚ö†Ô∏è Fel vid fr√•nkoppling: " + e.getMessage() + "\n");
        }
    }
}
